// Load environment variables from .env file (for local testing)
require('dotenv').config();

const axios = require('axios');
const fs = require('fs');
const path = require('path');

/**
 * Fetch the daily LeetCode problem
 */
async function getDailyProblem() {
    try {
        const query = `
      query questionOfToday {
        activeDailyCodingChallengeQuestion {
          date
          link
          question {
            questionId
            title
            titleSlug
            content
            difficulty
            exampleTestcases
            topicTags {
              name
            }
          }
        }
      }
    `;

        const response = await axios.post('https://leetcode.com/graphql', {
            query: query,
            variables: {}
        }, {
            headers: {
                'Content-Type': 'application/json',
                'Referer': 'https://leetcode.com'
            }
        });

        const data = response.data.data.activeDailyCodingChallengeQuestion;
        return {
            date: data.date,
            title: data.question.title,
            titleSlug: data.question.titleSlug,
            difficulty: data.question.difficulty,
            content: data.question.content,
            link: `https://leetcode.com${data.link}`,
            topicTags: data.question.topicTags.map(tag => tag.name),
            exampleTestcases: data.question.exampleTestcases
        };
    } catch (error) {
        console.error('Error fetching daily problem:', error.message);
        throw error;
    }
}

/**
 * Clean HTML content from problem description
 */
function cleanHTML(html) {
    return html
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .trim();
}

/**
 * Use Google Gemini AI to generate a solution in a specific language
 */
async function generateSolution(problem, language) {
    try {
        const cleanContent = cleanHTML(problem.content);

        const prompt = `You are an expert programmer solving LeetCode problems. 

Problem: ${problem.title}
Difficulty: ${problem.difficulty}
Topics: ${problem.topicTags.join(', ')}
Link: ${problem.link}

Problem Description:
${cleanContent}

IMPORTANT: Generate ONLY executable ${language} code. Do NOT include any markdown formatting, code blocks, or text outside the code.

Your response must be a complete, runnable ${language} file that includes:
1. A header comment block with:
   - Brief problem summary (1-2 sentences, not the full description)
   - Link to the problem
   - Approach explanation
   - Time complexity analysis
   - Space complexity analysis
2. Well-commented, executable code with inline comments explaining the logic
3. All explanations must be inside code comments (${language === 'Python' ? '#' : '//'} or /* */)

Keep the problem summary concise since the full problem description is in the README.md file.

The file should be ready to copy-paste and run directly in a ${language} compiler/interpreter.`;

        // Use Gemini REST API directly
        const apiKey = process.env.GEMINI_API_KEY;
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;

        const response = await axios.post(url, {
            contents: [{
                parts: [{
                    text: prompt
                }]
            }]
        }, {
            headers: {
                'Content-Type': 'application/json'
            }
        });

        return response.data.candidates[0].content.parts[0].text;
    } catch (error) {
        console.error(`Error generating ${language} solution:`, error.message);
        if (error.response) {
            console.error('API Error:', error.response.data);
        }
        throw error;
    }
}

/**
 * Save problem description
 */
function saveProblemDescription(problem, baseDir) {
    const filename = 'README.md';
    const filepath = path.join(baseDir, filename);

    const cleanContent = cleanHTML(problem.content);

    const fileContent = `# ${problem.title}

**Difficulty:** ${problem.difficulty}  
**Topics:** ${problem.topicTags.join(', ')}  
**Link:** ${problem.link}  
**Date:** ${problem.date}

---

## Problem Description

${cleanContent}

---

## Solutions

- [JavaScript Solution](./javascript/${problem.date}-${problem.titleSlug}.js)
- [Python Solution](./python/${problem.date}-${problem.titleSlug}.py)
- [Java Solution](./java/${problem.date}-${problem.titleSlug}.java)
- [C++ Solution](./cpp/${problem.date}-${problem.titleSlug}.cpp)

---

*Generated by AI on ${new Date().toISOString()}*
`;

    fs.writeFileSync(filepath, fileContent, 'utf8');
    console.log(`‚úÖ Problem description saved to: ${filename}`);
}

/**
 * Save solution to file
 */
function saveSolution(problem, solution, language, baseDir) {
    const extensions = {
        'JavaScript': 'js',
        'Python': 'py',
        'Java': 'java',
        'C++': 'cpp'
    };

    const langDir = path.join(baseDir, language.toLowerCase());

    // Create language directory if it doesn't exist
    if (!fs.existsSync(langDir)) {
        fs.mkdirSync(langDir, { recursive: true });
    }

    const filename = `${problem.date}-${problem.titleSlug}.${extensions[language]}`;
    const filepath = path.join(langDir, filename);

    // Save the solution directly - AI generates complete file with all comments
    fs.writeFileSync(filepath, solution, 'utf8');
    console.log(`   ‚úÖ ${language} solution saved`);

    return filepath;
}

/**
 * Main function
 */
async function main() {
    try {
        console.log('üöÄ Starting Daily LeetCode Solver...\n');

        // Check if API key is set
        if (!process.env.GEMINI_API_KEY) {
            throw new Error('GEMINI_API_KEY environment variable is not set');
        }

        // Fetch daily problem
        console.log('üì• Fetching daily LeetCode problem...');
        const problem = await getDailyProblem();
        console.log(`‚úÖ Found problem: ${problem.title} (${problem.difficulty})\n`);

        // Create base directory for today's problem
        const baseDir = path.join(__dirname, '../solutions', problem.date);
        if (!fs.existsSync(baseDir)) {
            fs.mkdirSync(baseDir, { recursive: true });
        }

        // Save problem description
        console.log('üìù Saving problem description...');
        saveProblemDescription(problem, baseDir);
        console.log();

        // Generate solutions in multiple languages
        const languages = ['JavaScript', 'Python', 'Java', 'C++'];

        for (const language of languages) {
            console.log(`ü§ñ Generating ${language} solution...`);
            const solution = await generateSolution(problem, language);
            saveSolution(problem, solution, language, baseDir);
        }

        console.log('\n‚ú® Done! All solutions ready for commit.');

    } catch (error) {
        console.error('‚ùå Error:', error.message);
        process.exit(1);
    }
}

// Run the script
main();
